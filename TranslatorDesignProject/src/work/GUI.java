/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package work;

import java.awt.Color;
import java.io.BufferedReader;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.io.Reader;
import java.io.StringReader;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.logging.Level;
import java.util.logging.Logger;
import java_cup.runtime.Symbol;

/**
 *
 * @author Lascau
 */
public class GUI extends javax.swing.JFrame {

    /**
     * Creates new form FrmPrincipal
     */
    public GUI() {
        initComponents();
        this.setLocationRelativeTo(null);
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        buttonAnalyser = new javax.swing.JButton();
        jScrollPane1 = new javax.swing.JScrollPane();
        outputTextBox = new javax.swing.JTextArea();
        jButton1 = new javax.swing.JButton();
        jScrollPane3 = new javax.swing.JScrollPane();
        inputTextBoxe = new javax.swing.JTextArea();

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);

        buttonAnalyser.setText("Lexical analysis");
        buttonAnalyser.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                buttonAnalyserActionPerformed(evt);
            }
        });

        outputTextBox.setEditable(false);
        outputTextBox.setColumns(20);
        outputTextBox.setFont(new java.awt.Font("Monospaced", 0, 18)); // NOI18N
        outputTextBox.setRows(5);
        jScrollPane1.setViewportView(outputTextBox);

        jButton1.setText("Synax Analysis");
        jButton1.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButton1ActionPerformed(evt);
            }
        });

        inputTextBoxe.setColumns(20);
        inputTextBoxe.setFont(new java.awt.Font("Monospaced", 0, 18)); // NOI18N
        inputTextBoxe.setRows(5);
        jScrollPane3.setViewportView(inputTextBoxe);

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(layout.createSequentialGroup()
                        .addGap(177, 177, 177)
                        .addComponent(buttonAnalyser, javax.swing.GroupLayout.PREFERRED_SIZE, 154, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addGap(156, 156, 156)
                        .addComponent(jButton1, javax.swing.GroupLayout.PREFERRED_SIZE, 128, javax.swing.GroupLayout.PREFERRED_SIZE))
                    .addGroup(layout.createSequentialGroup()
                        .addGap(112, 112, 112)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addComponent(jScrollPane3, javax.swing.GroupLayout.PREFERRED_SIZE, 602, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addComponent(jScrollPane1, javax.swing.GroupLayout.PREFERRED_SIZE, 602, javax.swing.GroupLayout.PREFERRED_SIZE))))
                .addContainerGap(121, Short.MAX_VALUE))
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
                .addGap(50, 50, 50)
                .addComponent(jScrollPane3, javax.swing.GroupLayout.PREFERRED_SIZE, 254, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, 41, Short.MAX_VALUE)
                .addComponent(jScrollPane1, javax.swing.GroupLayout.PREFERRED_SIZE, 262, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(44, 44, 44)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(buttonAnalyser, javax.swing.GroupLayout.PREFERRED_SIZE, 47, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(jButton1, javax.swing.GroupLayout.PREFERRED_SIZE, 47, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addGap(34, 34, 34))
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents

    private void buttonAnalyserActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_buttonAnalyserActionPerformed
        File file = new File("input.txt");
        PrintWriter out;
        try {
            out = new PrintWriter(file);
            out.print(inputTextBoxe.getText());
            out.close();
        } catch (FileNotFoundException ex) {
            Logger.getLogger(GUI.class.getName()).log(Level.SEVERE, null, ex);
        }
        try {
            Reader in = new BufferedReader(new FileReader("input.txt"));
            Lexer lexer = new Lexer(in);
            String answer = "";
            while (true) {
                Tokens tokens = lexer.yylex();
                if (tokens == null) {
                    answer += "End of file\n";
                    outputTextBox.setText(answer);
                    return;
                }
                switch (tokens) {
                    //Tags
                    case LabelOpen:
                        answer += lexer.lexeme + " -> " + tokens + "\n";
                        break;
                    case LabelClose:
                        answer += lexer.lexeme + " -> " + tokens + "\n";
                        break;
                    case LegendOpen:
                        answer += lexer.lexeme + " -> " + tokens + "\n";
                        break;
                    case LegendClose:
                        answer += lexer.lexeme + " -> " + tokens + "\n";
                        break;
                    case ListingOpen:
                        answer += lexer.lexeme + " -> " + tokens + "\n";
                        break;
                    case ListingClose:
                        answer += lexer.lexeme + " -> " + tokens + "\n";
                        break;
                    case NoframesOpen:
                        answer += lexer.lexeme + " -> " + tokens + "\n";
                        break;
                    case NoframesClose:
                        answer += lexer.lexeme + " -> " + tokens + "\n";
                        break;
                    case DDOpen:
                        answer += lexer.lexeme + " -> " + tokens + "\n";
                        break;
                    case DDClose:
                        answer += lexer.lexeme + " -> " + tokens + "\n";
                        break;
                    case DFNOpen:
                        answer += lexer.lexeme + " -> " + tokens + "\n";
                        break;
                    case DFNClose:
                        answer += lexer.lexeme + " -> " + tokens + "\n";
                        break;
                    case DtOpen:
                        answer += lexer.lexeme + " -> " + tokens + "\n";
                        break;
                    case DtClose:
                        answer += lexer.lexeme + " -> " + tokens + "\n";
                        break;
                    case EmOpen:
                        answer += lexer.lexeme + " -> " + tokens + "\n";
                        break;
                    case EmClose:
                        answer += lexer.lexeme + " -> " + tokens + "\n";
                        break;
                    case ScriptOpen:
                        answer += lexer.lexeme + " -> " + tokens + "\n";
                        break;
                    case ScriptClose:
                        answer += lexer.lexeme + " -> " + tokens + "\n";
                        break;
                    case SmallOpen:
                        answer += lexer.lexeme + " -> " + tokens + "\n";
                        break;
                    case SmallClose:
                        answer += lexer.lexeme + " -> " + tokens + "\n";
                        break;
                    case SpanOpen:
                        answer += lexer.lexeme + " -> " + tokens + "\n";
                        break;
                    case SpanClose:
                        answer += lexer.lexeme + " -> " + tokens + "\n";
                        break;
                    case StrikeOpen:
                        answer += lexer.lexeme + " -> " + tokens + "\n";
                        break;
                    case StrikeClose:
                        answer += lexer.lexeme + " -> " + tokens + "\n";
                        break;
                     case StyleOpen:
                        answer += lexer.lexeme + " -> " + tokens + "\n";
                        break;
                    case StyleClose:
                        answer += lexer.lexeme + " -> " + tokens + "\n";
                        break;
                    case SubOpen:
                        answer += lexer.lexeme + " -> " + tokens + "\n";
                        break;
                    case SubClose:
                        answer += lexer.lexeme + " -> " + tokens + "\n";
                        break;
                    case FrameOpen:
                        answer += lexer.lexeme + " -> " + tokens + "\n";
                        break;
                    case FrameClose:
                        answer += lexer.lexeme + " -> " + tokens + "\n";
                        break;
                    case FramesetOpen:
                        answer += lexer.lexeme + " -> " + tokens + "\n";
                        break;
                    case FramesetClose:
                        answer += lexer.lexeme + " -> " + tokens + "\n";
                        break;
                    case IframeOpen:
                        answer += lexer.lexeme + " -> " + tokens + "\n";
                        break;
                    case IframeClose:
                        answer += lexer.lexeme + " -> " + tokens + "\n";
                        break;
                    case InsOpen:
                        answer += lexer.lexeme + " -> " + tokens + "\n";
                        break;
                    case InsClose:
                        answer += lexer.lexeme + " -> " + tokens + "\n";
                        break;
                    case KbdOpen:
                        answer += lexer.lexeme + " -> " + tokens + "\n";
                        break;
                    case KbdClose:
                        answer += lexer.lexeme + " -> " + tokens + "\n";
                        break;
                    case ColgroupOpen:
                        answer += lexer.lexeme + " -> " + tokens + "\n";
                        break;
                    case ColgroupClose:
                        answer += lexer.lexeme + " -> " + tokens + "\n";
                        break;
                    case FieldsetOpen:
                        answer += lexer.lexeme + " -> " + tokens + "\n";
                        break;
                    case FieldsetClose:
                        answer += lexer.lexeme + " -> " + tokens + "\n";
                        break;
                    case UOpen:
                        answer += lexer.lexeme + " -> " + tokens + "\n";
                        break;
                    case UClose:
                        answer += lexer.lexeme + " -> " + tokens + "\n";
                        break;
                    case NoscriptOpen:
                        answer += lexer.lexeme + " -> " + tokens + "\n";
                        break;
                    case NoscriptClose:
                        answer += lexer.lexeme + " -> " + tokens + "\n";
                        break;
                    case ObjectOpen:
                        answer += lexer.lexeme + " -> " + tokens + "\n";
                        break;
                    case ObjectClose:
                        answer += lexer.lexeme + " -> " + tokens + "\n";
                        break;
                    case OptgroupOpen:
                        answer += lexer.lexeme + " -> " + tokens + "\n";
                        break;
                    case OptgroupClose:
                        answer += lexer.lexeme + " -> " + tokens + "\n";
                        break;
                    case ParamOpen:
                        answer += lexer.lexeme + " -> " + tokens + "\n";
                        break;
                    case ParamClose:
                        answer += lexer.lexeme + " -> " + tokens + "\n";
                        break;
                    case PlaintextOpen:
                        answer += lexer.lexeme + " -> " + tokens + "\n";
                        break;
                    case PlaintextClose:
                        answer += lexer.lexeme + " -> " + tokens + "\n";
                        break;
                    case TheadOpen:
                        answer += lexer.lexeme + " -> " + tokens + "\n";
                        break;
                    case TheadClose:
                        answer += lexer.lexeme + " -> " + tokens + "\n";
                        break;
                    case TitleOpen:
                        answer += lexer.lexeme + " -> " + tokens + "\n";
                        break;
                    case TitleClose:
                        answer += lexer.lexeme + " -> " + tokens + "\n";
                        break;
                    case IOpen:
                        answer += lexer.lexeme + " -> " + tokens + "\n";
                        break;
                    case IClose:
                        answer += lexer.lexeme + " -> " + tokens + "\n";
                        break;
                    case BlockquoteOpen:
                        answer += lexer.lexeme + " -> " + tokens + "\n";
                        break;
                    case BlockquoteClose:
                        answer += lexer.lexeme + " -> " + tokens + "\n";
                        break;
                    case SOpen:
                        answer += lexer.lexeme + " -> " + tokens + "\n";
                        break;
                    case SClose:
                        answer += lexer.lexeme + " -> " + tokens + "\n";
                        break;
                    case CaptionOpen:
                        answer += lexer.lexeme + " -> " + tokens + "\n";
                        break;
                    case CaptionClose:
                        answer += lexer.lexeme + " -> " + tokens + "\n";
                        break;
                    case CenterOpen:
                        answer += lexer.lexeme + " -> " + tokens + "\n";
                        break;
                    case CenterClose:
                        answer += lexer.lexeme + " -> " + tokens + "\n";
                        break;
                    case CiteOpen:
                        answer += lexer.lexeme + " -> " + tokens + "\n";
                        break;
                    case CiteClose:
                        answer += lexer.lexeme + " -> " + tokens + "\n";
                        break;
                    case ColOpen:
                        answer += lexer.lexeme + " -> " + tokens + "\n";
                        break;
                    case ColClose:
                        answer += lexer.lexeme + " -> " + tokens + "\n";
                        break;
                    case QOpen:
                        answer += lexer.lexeme + " -> " + tokens + "\n";
                        break;
                    case TTOpen:
                        answer += lexer.lexeme + " -> " + tokens + "\n";
                        break;
                    case TTClose:
                        answer += lexer.lexeme + " -> " + tokens + "\n";
                        break;
                    case QClose:
                        answer += lexer.lexeme + " -> " + tokens + "\n";
                        break;
                    case VarOpen:
                        answer += lexer.lexeme + " -> " + tokens + "\n";
                        break;
                    case VarClose:
                        answer += lexer.lexeme + " -> " + tokens + "\n";
                        break;
                    case StrongOpen:
                        answer += lexer.lexeme + " -> " + tokens + "\n";
                        break;
                    case StrongClose:
                        answer += lexer.lexeme + " -> " + tokens + "\n";
                        break;
                    case XmpOpen:
                        answer += lexer.lexeme + " -> " + tokens + "\n";
                        break;
                    case XmpClose:
                        answer += lexer.lexeme + " -> " + tokens + "\n";
                        break;
                    case DelOpen:
                        answer += lexer.lexeme + " -> " + tokens + "\n";
                        break;
                    case DelClose:
                        answer += lexer.lexeme + " -> " + tokens + "\n";
                        break;
                    case SampOpen:
                        answer += lexer.lexeme + " -> " + tokens + "\n";
                        break;
                    case SampClose:
                        answer += lexer.lexeme + " -> " + tokens + "\n";
                        break;
                    case HeadOpen:
                        answer += lexer.lexeme + " -> " + tokens + "\n";
                        break;
                    case HeadClose:
                        answer += lexer.lexeme + " -> " + tokens + "\n";
                        break;
                    case CodeOpen:
                        answer += lexer.lexeme + " -> " + tokens + "\n";
                        break;
                    case CodeClose:
                        answer += lexer.lexeme + " -> " + tokens + "\n";
                        break;
                    case ButtonOpen:
                        answer += lexer.lexeme + " -> " + tokens + "\n";
                        break;
                    case ButtonClose:
                        answer += lexer.lexeme + " -> " + tokens + "\n";
                        break; 
                    case BOpen:
                        answer += lexer.lexeme + " -> " + tokens + "\n";
                        break;
                    case BClose:
                        answer += lexer.lexeme + " -> " + tokens + "\n";
                        break;
                    case LiOpen:
                        answer += lexer.lexeme + " -> " + tokens + "\n";
                        break;
                    case LiClose:
                        answer += lexer.lexeme + " -> " + tokens + "\n";
                        break; 
                    case MapOpen:
                        answer += lexer.lexeme + " -> " + tokens + "\n";
                        break;
                    case MapClose:
                        answer += lexer.lexeme + " -> " + tokens + "\n";
                        break;
                    case MenuOpen:
                        answer += lexer.lexeme + " -> " + tokens + "\n";
                        break;
                    case MenuClose:
                        answer += lexer.lexeme + " -> " + tokens + "\n";
                        break;
                    case MetaOpen:
                        answer += lexer.lexeme + " -> " + tokens + "\n";
                        break;
                    case MetaClose:
                        answer += lexer.lexeme + " -> " + tokens + "\n";
                        break;
                    case NextidOpen:
                        answer += lexer.lexeme + " -> " + tokens + "\n";
                        break;
                    case NextidClose:
                        answer += lexer.lexeme + " -> " + tokens + "\n";
                        break;
                    case OlOpen:
                        answer += lexer.lexeme + " -> " + tokens + "\n";
                        break;
                    case OlClose:
                        answer += lexer.lexeme + " -> " + tokens + "\n";
                        break;
                    case OptionOpen:
                        answer += lexer.lexeme + " -> " + tokens + "\n";
                        break;
                    case OptionClose:
                        answer += lexer.lexeme + " -> " + tokens + "\n";
                        break;
                     case POpen:
                        answer += lexer.lexeme + " -> " + tokens + "\n";
                        break;
                    case PClose:
                        answer += lexer.lexeme + " -> " + tokens + "\n";
                        break;
                    case PreOpen:
                        answer += lexer.lexeme + " -> " + tokens + "\n";
                        break;
                    case PreClose:
                        answer += lexer.lexeme + " -> " + tokens + "\n";
                        break;
                    case SelectOpen:
                        answer += lexer.lexeme + " -> " + tokens + "\n";
                        break;
                    case SelectClose:
                        answer += lexer.lexeme + " -> " + tokens + "\n";
                        break;
                    case TableOpen:
                        answer += lexer.lexeme + " -> " + tokens + "\n";
                        break;
                    case TableClose:
                        answer += lexer.lexeme + " -> " + tokens + "\n";
                        break;
                    case TdOpen:
                        answer += lexer.lexeme + " -> " + tokens + "\n";
                        break;
                    case TdClose:
                        answer += lexer.lexeme + " -> " + tokens + "\n";
                        break;
                    case TextareaOpen:
                        answer += lexer.lexeme + " -> " + tokens + "\n";
                        break;
                    case TextareaClose:
                        answer += lexer.lexeme + " -> " + tokens + "\n";
                        break;
                    case ThOpen:
                        answer += lexer.lexeme + " -> " + tokens + "\n";
                        break;
                    case ThClose:
                        answer += lexer.lexeme + " -> " + tokens + "\n";
                        break;
                    case TrOpen:
                        answer += lexer.lexeme + " -> " + tokens + "\n";
                        break;
                    case TrClose:
                        answer += lexer.lexeme + " -> " + tokens + "\n";
                        break;
                    case UlOpen:
                        answer += lexer.lexeme + " -> " + tokens + "\n";
                        break;
                    case UlClose:
                        answer += lexer.lexeme + " -> " + tokens + "\n";
                        break;
                    case TbodyOpen:
                        answer += lexer.lexeme + " -> " + tokens + "\n";
                        break;
                    case TbodyClose:
                        answer += lexer.lexeme + " -> " + tokens + "\n";
                        break;
                    case AppletOpen:
                        answer += lexer.lexeme + " -> " + tokens + "\n";
                        break;
                    case AppletClose:
                        answer += lexer.lexeme + " -> " + tokens + "\n";
                        break; 
                    case AddressOpen:
                        answer += lexer.lexeme + " -> " + tokens + "\n";
                        break;
                    case AddressClose:
                        answer += lexer.lexeme + " -> " + tokens + "\n";
                        break; 
                    case AcronymOpen:
                        answer += lexer.lexeme + " -> " + tokens + "\n";
                        break;
                    case AcronymClose:
                        answer += lexer.lexeme + " -> " + tokens + "\n";
                        break; 
                    case AbbrOpen:
                        answer += lexer.lexeme + " -> " + tokens + "\n";
                        break;
                    case AbbrClose:
                        answer += lexer.lexeme + " -> " + tokens + "\n";
                        break;
                    case DlOpen:
                        answer += lexer.lexeme + " -> " + tokens + "\n";
                        break;
                    case DlClose:
                        answer += lexer.lexeme + " -> " + tokens + "\n";
                        break;
                    case FontOpen:
                        answer += lexer.lexeme + " -> " + tokens + "\n";
                        break;
                    case FontClose:
                        answer += lexer.lexeme + " -> " + tokens + "\n";
                        break; 
                    case FormOpen:
                        answer += lexer.lexeme + " -> " + tokens + "\n";
                        break;
                    case FormClose:
                        answer += lexer.lexeme + " -> " + tokens + "\n";
                        break; 
                    case HnOpen:
                        answer += lexer.lexeme + " -> " + tokens + "\n";
                        break;
                    case HnClose:
                        answer += lexer.lexeme + " -> " + tokens + "\n";
                        break;
                     case HtmlOpen:
                        answer += lexer.lexeme + " -> " + tokens + "\n";
                        break;
                    case HtmlClose:
                        answer += lexer.lexeme + " -> " + tokens + "\n";
                        break;
                    case ImgOpen:
                        answer += lexer.lexeme + " -> " + tokens + "\n";
                        break;
                    case ImgClose:
                        answer += lexer.lexeme + " -> " + tokens + "\n";
                        break;
                    case InputOpen:
                        answer += lexer.lexeme + " -> " + tokens + "\n";
                        break;
                    case InputClose:
                        answer += lexer.lexeme + " -> " + tokens + "\n";
                        break;
                    case IsindexOpen:
                        answer += lexer.lexeme + " -> " + tokens + "\n";
                        break;
                    case IsindexClose:
                        answer += lexer.lexeme + " -> " + tokens + "\n";
                        break;
                    case HrOpen:
                        answer += lexer.lexeme + " -> " + tokens + "\n";
                        break;
                    case HrClose:
                        answer += lexer.lexeme + " -> " + tokens + "\n";
                        break; 
                    case DivOpen:
                        answer += lexer.lexeme + " -> " + tokens + "\n";
                        break;
                    case DivClose:
                        answer += lexer.lexeme + " -> " + tokens + "\n";
                        break;
                    case BigOpen:
                        answer += lexer.lexeme + " -> " + tokens + "\n";
                        break;
                    case BigClose:
                        answer += lexer.lexeme + " -> " + tokens + "\n";
                        break;
                    case BdoOpen:
                        answer += lexer.lexeme + " -> " + tokens + "\n";
                        break;
                    case BdoClose:
                        answer += lexer.lexeme + " -> " + tokens + "\n";
                        break;
                    case BaseFontOpen:
                       answer += lexer.lexeme + " -> " + tokens + "\n";
                        break;
                    case BaseFontClose:
                        answer += lexer.lexeme + " -> " + tokens + "\n";
                        break;
                    case BodyOpen:
                        answer += lexer.lexeme + " -> " + tokens + "\n";
                        break;
                    case BodyClose:
                        answer += lexer.lexeme + " -> " + tokens + "\n";
                        break;
                    case AOpen:
                        answer += lexer.lexeme + " -> " + tokens + "\n";
                        break;
                    case AClose:
                        answer += lexer.lexeme + " -> " + tokens + "\n";
                        break;
                    case AreaOpen:
                        answer += lexer.lexeme + " -> " + tokens + "\n";
                        break;
                    case AreaClose:
                        answer += lexer.lexeme + " -> " + tokens + "\n";
                        break;
                    case BaseOpen:
                        answer += lexer.lexeme + " -> " + tokens + "\n";
                        break;
                    case BaseClose:
                        answer += lexer.lexeme + " -> " + tokens + "\n";
                        break;
                    case DirOpen:
                        answer += lexer.lexeme + " -> " + tokens + "\n";
                        break;
                    case DirClose:
                        answer += lexer.lexeme + " -> " + tokens + "\n";
                        break;
                    //Attributes
                    case SizeAttr:                       
                        answer += lexer.lexeme + " -> " + tokens + "-> Value: " + lexer.lexeme.substring(lexer.lexeme.indexOf('"')) + "\n";
                        break;
                    case WidthAttr:
                        answer += lexer.lexeme + " -> " + tokens + "-> Value: " + lexer.lexeme.substring(lexer.lexeme.indexOf('"')) + "\n";
                        break;
                    case NoshadeAttr:
                        answer += lexer.lexeme + " -> " + tokens + "\n";
                        break;
                    case AlignAttr:
                        String valAllign = lexer.lexeme.substring(lexer.lexeme.indexOf('"') + 1, lexer.lexeme.length() - 1);
                        if (valAllign.equals("center") || valAllign.equals("left") || valAllign.equals("right")) {
                            answer += lexer.lexeme + " -> " + tokens + "-> Value: " +  valAllign + "\n";
                        } else {
                            answer += "Syntax error!\n";
                        }
                        break;
                    case NameAttr:                       
                        answer += lexer.lexeme + " -> " + tokens + "-> Value: " + lexer.lexeme.substring(lexer.lexeme.indexOf('"')) + "\n";
                        break;
                    case HrefAttr:                       
                        answer += lexer.lexeme + " -> " + tokens + "-> Value: " + lexer.lexeme.substring(lexer.lexeme.indexOf('"')) + "\n";
                        break;
                    case RelAttr:                       
                        answer += lexer.lexeme + " -> " + tokens + "-> Value: " + lexer.lexeme.substring(lexer.lexeme.indexOf('"')) + "\n";
                        break;
                    case RevAttr:                       
                        answer += lexer.lexeme + " -> " + tokens + "-> Value: " + lexer.lexeme.substring(lexer.lexeme.indexOf('"')) + "\n";
                        break;
                    case TitleAttr:                       
                        answer += lexer.lexeme + " -> " + tokens + "-> Value: " + lexer.lexeme.substring(lexer.lexeme.indexOf('"')) + "\n";
                        break;
                    case UrnAttr:                       
                        answer += lexer.lexeme + " -> " + tokens + "-> Value: " + lexer.lexeme.substring(lexer.lexeme.indexOf('"')) + "\n";
                        break;
                    case MethodsAttr:                       
                        answer += lexer.lexeme + " -> " + tokens + "-> Value: " + lexer.lexeme.substring(lexer.lexeme.indexOf('"')) + "\n";
                        break;
                    case ShapeAttr:                       
                        answer += lexer.lexeme + " -> " + tokens + "-> Value: " + lexer.lexeme.substring(lexer.lexeme.indexOf('"')) + "\n";
                        break;
                    case CoordsAttr:                       
                        answer += lexer.lexeme + " -> " + tokens + "-> Value: " + lexer.lexeme.substring(lexer.lexeme.indexOf('"')) + "\n";
                        break;
                    case AltAttr:                       
                        answer += lexer.lexeme + " -> " + tokens + "-> Value: " + lexer.lexeme.substring(lexer.lexeme.indexOf('"')) + "\n";
                        break;
                    case NohrefAttr:                       
                        answer += lexer.lexeme + " -> " + tokens + "-> Value: " + lexer.lexeme.substring(lexer.lexeme.indexOf('"')) + "\n";
                        break;
                    case BgcolorAttr:                       
                        answer += lexer.lexeme + " -> " + tokens + "-> Value: " + lexer.lexeme.substring(lexer.lexeme.indexOf('"')) + "\n";
                        break;
                    case BackgroundAttr:                       
                        answer += lexer.lexeme + " -> " + tokens + "-> Value: " + lexer.lexeme.substring(lexer.lexeme.indexOf('"')) + "\n";
                        break;
                    case TextAttr:                       
                        answer += lexer.lexeme + " -> " + tokens + "-> Value: " + lexer.lexeme.substring(lexer.lexeme.indexOf('"')) + "\n";
                        break;
                    case LinkAttr:                       
                        answer += lexer.lexeme + " -> " + tokens + "-> Value: " + lexer.lexeme.substring(lexer.lexeme.indexOf('"')) + "\n";
                        break;
                    case VlinkAttr:                       
                        answer += lexer.lexeme + " -> " + tokens + "-> Value: " + lexer.lexeme.substring(lexer.lexeme.indexOf('"')) + "\n";
                        break;
                    case AlinkAttr:                       
                        answer += lexer.lexeme + " -> " + tokens + "-> Value: " + lexer.lexeme.substring(lexer.lexeme.indexOf('"')) + "\n";
                        break;
                    case VersionAttr:                       
                        answer += lexer.lexeme + " -> " + tokens + "-> Value: " + lexer.lexeme.substring(lexer.lexeme.indexOf('"')) + "\n";
                        break;
                    case ColorAttr:                       
                        answer += lexer.lexeme + " -> " + tokens + "-> Value: " + lexer.lexeme.substring(lexer.lexeme.indexOf('"')) + "\n";
                        break;
                    case CompactAttr:                       
                        answer += lexer.lexeme + " -> " + tokens + "-> Value: " + lexer.lexeme.substring(lexer.lexeme.indexOf('"')) + "\n";
                        break;
                    case ClearAttr:                       
                        answer += lexer.lexeme + " -> " + tokens + "-> Value: " + lexer.lexeme.substring(lexer.lexeme.indexOf('"')) + "\n";
                        break;
                    case ActionAttr:                       
                        answer += lexer.lexeme + " -> " + tokens + "-> Value: " + lexer.lexeme.substring(lexer.lexeme.indexOf('"')) + "\n";
                        break;
                    case EnctypeAttr:                       
                        answer += lexer.lexeme + " -> " + tokens + "-> Value: " + lexer.lexeme.substring(lexer.lexeme.indexOf('"')) + "\n";
                        break;
                    case MethodAttr:                       
                        answer += lexer.lexeme + " -> " + tokens + "-> Value: " + lexer.lexeme.substring(lexer.lexeme.indexOf('"')) + "\n";
                        break;
                    case SrcAttr:                       
                        answer += lexer.lexeme + " -> " + tokens + "-> Value: " + lexer.lexeme.substring(lexer.lexeme.indexOf('"')) + "\n";
                        break;
                    case HeightAttr:                       
                        answer += lexer.lexeme + " -> " + tokens + "-> Value: " + lexer.lexeme.substring(lexer.lexeme.indexOf('"')) + "\n";
                        break;
                    case HspaceAttr:                       
                        answer += lexer.lexeme + " -> " + tokens + "-> Value: " + lexer.lexeme.substring(lexer.lexeme.indexOf('"')) + "\n";
                        break;
                    case VspaceAttr:                       
                        answer += lexer.lexeme + " -> " + tokens + "-> Value: " + lexer.lexeme.substring(lexer.lexeme.indexOf('"')) + "\n";
                        break;
                    case BorderAttr:                       
                        answer += lexer.lexeme + " -> " + tokens + "-> Value: " + lexer.lexeme.substring(lexer.lexeme.indexOf('"')) + "\n";
                        break;
                    case UsemapAttr:                       
                        answer += lexer.lexeme + " -> " + tokens + "-> Value: " + lexer.lexeme.substring(lexer.lexeme.indexOf('"')) + "\n";
                        break;
                    case IsmapAttr:                       
                        answer += lexer.lexeme + " -> " + tokens + "-> Value: " + lexer.lexeme.substring(lexer.lexeme.indexOf('"')) + "\n";
                        break;
                    case TypeAttr:                       
                        answer += lexer.lexeme + " -> " + tokens + "-> Value: " + lexer.lexeme.substring(lexer.lexeme.indexOf('"')) + "\n";
                        break;
                    case ValueAttr:                       
                        answer += lexer.lexeme + " -> " + tokens + "-> Value: " + lexer.lexeme.substring(lexer.lexeme.indexOf('"')) + "\n";
                        break;
                    case MaxlengthAttr:                       
                        answer += lexer.lexeme + " -> " + tokens + "-> Value: " + lexer.lexeme.substring(lexer.lexeme.indexOf('"')) + "\n";
                        break;
                    case CheckedAttr:                       
                        answer += lexer.lexeme + " -> " + tokens + "-> Value: " + lexer.lexeme.substring(lexer.lexeme.indexOf('"')) + "\n";
                        break;
                    case PromptAttr:                       
                        answer += lexer.lexeme + " -> " + tokens + "-> Value: " + lexer.lexeme.substring(lexer.lexeme.indexOf('"')) + "\n";
                        break;
                    case IdAttr:                       
                        answer += lexer.lexeme + " -> " + tokens + "-> Value: " + lexer.lexeme.substring(lexer.lexeme.indexOf('"')) + "\n";
                        break;
                    case HTTP_EQUIV_Attr:                       
                        answer += lexer.lexeme + " -> " + tokens + "-> Value: " + lexer.lexeme.substring(lexer.lexeme.indexOf('"')) + "\n";
                        break;
                    case ContentAttr:                       
                        answer += lexer.lexeme + " -> " + tokens + "-> Value: " + lexer.lexeme.substring(lexer.lexeme.indexOf('"')) + "\n";
                        break;
                    case StartAttr:                       
                        answer += lexer.lexeme + " -> " + tokens + "-> Value: " + lexer.lexeme.substring(lexer.lexeme.indexOf('"')) + "\n";
                        break;
                    case SelectedAttr:                       
                        answer += lexer.lexeme + " -> " + tokens + "-> Value: " + lexer.lexeme.substring(lexer.lexeme.indexOf('"')) + "\n";
                        break;
                    case MultipleAttr:                       
                        answer += lexer.lexeme + " -> " + tokens + "-> Value: " + lexer.lexeme.substring(lexer.lexeme.indexOf('"')) + "\n";
                        break;
                    case CellspacingAttr:                       
                        answer += lexer.lexeme + " -> " + tokens + "-> Value: " + lexer.lexeme.substring(lexer.lexeme.indexOf('"')) + "\n";
                        break;
                    case CellpaddingAttr:                       
                        answer += lexer.lexeme + " -> " + tokens + "-> Value: " + lexer.lexeme.substring(lexer.lexeme.indexOf('"')) + "\n";
                        break;
                    case ValignAttr:                       
                        answer += lexer.lexeme + " -> " + tokens + "-> Value: " + lexer.lexeme.substring(lexer.lexeme.indexOf('"')) + "\n";
                        break;
                    case RowspanAttr:                       
                        answer += lexer.lexeme + " -> " + tokens + "-> Value: " + lexer.lexeme.substring(lexer.lexeme.indexOf('"')) + "\n";
                        break;
                    case ColspanAttr:                       
                        answer += lexer.lexeme + " -> " + tokens + "-> Value: " + lexer.lexeme.substring(lexer.lexeme.indexOf('"')) + "\n";
                        break;
                    case NowrapAttr:                       
                        answer += lexer.lexeme + " -> " + tokens + "-> Value: " + lexer.lexeme.substring(lexer.lexeme.indexOf('"')) + "\n";
                        break;
                    case RowsAttr:                       
                        answer += lexer.lexeme + " -> " + tokens + "-> Value: " + lexer.lexeme.substring(lexer.lexeme.indexOf('"')) + "\n";
                        break;
                    case ColsAttr:                       
                        answer += lexer.lexeme + " -> " + tokens + "-> Value: " + lexer.lexeme.substring(lexer.lexeme.indexOf('"')) + "\n";
                        break;
                    //Content
                    case Content: 
                       answer += lexer.lexeme.substring(1) + " -> " + tokens + "\n";
                       break;
                    //Error
                    case ERROR:
                        System.out.println("HATZ");
                        answer += "Sytax error\n";
                        break;

                    default:
                        answer += "Token: " + " -> " + tokens + "\n";
                        break;
                }
            }
        } catch (FileNotFoundException ex) {
            Logger.getLogger(GUI.class.getName()).log(Level.SEVERE, null, ex);
        } catch (IOException ex) {
            Logger.getLogger(GUI.class.getName()).log(Level.SEVERE, null, ex);
        }
    }//GEN-LAST:event_buttonAnalyserActionPerformed

    private void jButton1ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButton1ActionPerformed
        // TODO add your handling code here:
        String st = inputTextBoxe.getText();
        Sintax s = new Sintax(new work.LexerCup(new StringReader(st)));

        try {
            s.parse();
            // print abstract syntax tree
            if (s.root != null) {
                s.root.printAst(0);
            }
            outputTextBox.setText("Successfully checked! ✔");
            outputTextBox.setForeground(new Color (25,111,61));
        } catch (Exception ex) {
            Symbol sym = s.getS();

            outputTextBox.setText("Syntax error! \n"+ "Line: " + (sym.right + 1) + ", Column: " + (sym.left + 1) + "\nSymbol starting at: " + sym.value + "\n");
            outputTextBox.setForeground(Color.red);
        }
    }//GEN-LAST:event_jButton1ActionPerformed

    /**
     * @param args the command line arguments
     */
    public static void main(String args[]) {
        /* Set the Nimbus look and feel */
        //<editor-fold defaultstate="collapsed" desc=" Look and feel setting code (optional) ">
        /* If Nimbus (introduced in Java SE 6) is not available, stay with the default look and feel.
         * For details see http://download.oracle.com/javase/tutorial/uiswing/lookandfeel/plaf.html 
         */
        try {
            for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {
                if ("Nimbus".equals(info.getName())) {
                    javax.swing.UIManager.setLookAndFeel(info.getClassName());
                    break;
                }
            }
        } catch (ClassNotFoundException ex) {
            java.util.logging.Logger.getLogger(GUI.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (InstantiationException ex) {
            java.util.logging.Logger.getLogger(GUI.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (IllegalAccessException ex) {
            java.util.logging.Logger.getLogger(GUI.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (javax.swing.UnsupportedLookAndFeelException ex) {
            java.util.logging.Logger.getLogger(GUI.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        }
        //</editor-fold>
        //</editor-fold>

        /* Create and display the form */
        java.awt.EventQueue.invokeLater(new Runnable() {
            public void run() {
                new GUI().setVisible(true);
            }
        });
    }

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JButton buttonAnalyser;
    private javax.swing.JTextArea inputTextBoxe;
    private javax.swing.JButton jButton1;
    private javax.swing.JScrollPane jScrollPane1;
    private javax.swing.JScrollPane jScrollPane3;
    private javax.swing.JTextArea outputTextBox;
    // End of variables declaration//GEN-END:variables
}
